# Takes a command line argument to the path of a text file
# This contains filepaths on the system to .csv files that have been
# Generated by the car simulator. 
# Go through each of these files and generate a heat profile of the battery
# THis heat then needs to be analysed by the machine learning to control the fans

#Import the command line arguments
import sys
#Used for trig functions
import math
#Regular expressions
import re
#Used to get the epoch time to calculate the time difference dt
import datetime
import time
#Allows me to stop the script for debugging purposes
import sys

###########################Define Vars###############################
# Define variables of typical EV
varM = 380.0            # vehicle mass (TBRe car)
vara = 2.68             # vehicle acceleration
varu = 2.68             # vehicle decellaration TODO: Research or calculate this value
varFm = 1.05            # converted mass factor of rotational components
varCrr = 0.02           # Rolling resistance coefficient
varCd = 0.5             # Aerodynamic drag coefficient
varg = 9.81             # Gravity
varp = 1.225            # Density of ambient air
varA = 2.0              # Vehicle frontal area TODO: Find this out for TBRe
varTheta = 0            # Uphill angle in radians (Uphill +ve)
varV = 0                # Vehicle speed (km)
varVw = 0               # Wind speed in the direction of the car

# Q = mcDeltaT for li-ion batteries 
specHeatCap = 795.0     # Specific heat capacity (in seconds)
Tamb = float(25 + 273)  # Ambient (initial) temperature (kelin)
battMass = 80.0         # Mass of the battery in kg

# Conversion factors
mphTomps = 0.44704

# Fan infomation
maxFanDraw = 36.0       # 36W, based on 2.8W power consumption and 12 fans on the TBRe car
fanVoltage = 12.0       # 12V DC
                        # Fan current is the power divided by the voltage
fanCurrent = maxFanDraw / fanVoltage
coolingFloor = 285      # Min temperature the fans can physically get the batteries, 12oC

# Battery infomation
currDraw = 240.0        # 240A, continous current draw of 30A with 8 cells in parallel
battCapacity = 18.7     # 180Ah total capcity of the battery, note unit of hours!
battVoltageNom = 388.0  # 388V nominal voltage
battResistance = 0.2304 # 0.2304ohm, 108 in series, 6 in parallel, 12.8E-3 per cell
regenEfficiency = 0.55  # 55% Efficiecny of the velocity converted to regen power, and this power used for recharging
maxTemp = 307           # Kelvin, 35oC
minTemp = 288           # Kevlin, 15oC

# Testbench variables
verbOutput = False      # If true then the output csv will contain a lot more data, used to train machine learning models

########################Define functions#############################

#Calculate the instantaneousPowerDrive using the throttle and velocity
def instantaneousPowerDrive (acceleration, velocity, dt):
    #Vecloty
    velocity = float(velocity)
    # Acceleration already scaled by dt
    #Calculate the instantaneous power 
    value = ((float(varFm) * float(varM) * float(acceleration) * velocity) + 
            (float(varM) * float(varg) * float(varCrr) * float(math.cos(varTheta))) + 
            (float(0.5) * float(varp) * float(varA) * float(varCd) * 
                (float(velocity) - float(varVw)) ** 2) + 
            (float(varM) * float(varg) * float(velocity) * float(math.sin(varTheta))))
    value *= dt
    return value

#Calculate the instantaneousPower while breaking using the break and velocity
def instantaneousPowerBreak (decellaration, velocity, dt):
    #scale velocity by dt
    velocity = float(velocity) * dt
    # Decelleration scaled by dt
    #Calculate the instantaneous power 
    value = ((float(varFm) * float(varM) * float(decellaration) * velocity) - 
            (float(varM) * float(varg) * float(varCrr) * float(math.cos(varTheta))) - 
            (float(0.5) * float(varp) * float(varA) * float(varCd) * 
                (float(velocity) - float(varVw)) ** 2) - 
            (float(varM) * float(varg) * float(velocity) * float(math.sin(varTheta))))
    return value

#Calculate the cooling which occurs, depending on the vehicle speed
#In m/s, and the accumulator 
#Uses fluid dynamics of dry air, with flow across a tube bank
def calculateCooling(coolingThrottle, dt):
    #Make sure the cooling throttle is between 0 and 1
    coolingThrottle = 1 if (coolingThrottle > 1) else coolingThrottle
    coolingThrottle = 0 if (coolingThrottle < 0) else coolingThrottle
    #Work out the air speed, max 10m/s
    coolAirSpeed = float(coolingThrottle) * 4.0

    #Caulcate Vmax, the max velocity of the air through the staggered tube bank arrangement
    St = 25.0 * (10.0 ** -3.0) 
    D = 18.65 * (10.0 ** -3.0) 
    Vmax = (St * coolAirSpeed) / (St - D)

    #Properties of dry air
    density = 1.177         
    dynamVis = 1.846 * (10.0 ** -5.0)
    criticalDimension = 0.01865

    #Calculate value of Re, pre computed values for desnity, cell size and dynamic viscosity
    #dt cancells out, but in the equations for clairty
    Re = (density * criticalDimension) / (dynamVis) * Vmax

    #Calculate the prandtl number, which is based on the Tfilm temperature 
    #Tfilm is the average of the Tamb and the heat of the object
    Pr = 0.706
    Prs = 0.708

    #Calculate the nusselt number, using the Re and the prandtl number
    #St and Sl are the dimensions of the staggered battery arangement
    St = 24.0 * (10.0 ** -3)
    Sl = 22.0 * (10.0 ** -3)
    Nu = (0.35 * ((St / Sl) ** (0.2)) * (Re ** 0.6) * (Pr ** 0.36) * ((Pr / Prs) ** 0.25))
        
    #Calculate the value of h, 
    h = ((2.624 * (10.0 ** -2.0) * Nu) / 0.01865)

    #Calculate the heat loss Q

    Q = h * 0.0044 * (maxTemp - Tamb)

    #6 sub packs, 108 in series and 6 in parallel 636 total. However, with the depth the air cooling tends towards
    # to decrease, so only have the 6 sub packs with the 6 in the string being cooled in the model
    cellCount = 6.0 * 6.0

    #Calculate the cooling value over the cells, but multiplied by dt, and the number of sub packs
    coolingValue = Q * dt * cellCount

    return coolingValue

#Calculated the time difference in milliseconds
#Regex on each filepath to get the time variables
#Create an object to get the epoch time
#Differene in epoch time is the dt (in seconds)
def calculateDt(prev, current):
    #Calculate the epoch of the prev tick 
    #File last value is millisconds so convert to microseconds in datetime constructor
    p = re.search(r'.+center_(\d+)_(\d+)_(\d+)_(\d+)_(\d+)_(\d+)_(\d+).jpg', prev)
    prevTime = datetime.datetime(int(p.groups(1)[0]), int(p.groups(1)[1]), int(p.groups(1)[2]),
            int(p.groups(1)[3]), int(p.groups(1)[4]), int(p.groups(1)[5]), (int(p.groups(1)[6]) * 1000))
    prevEpoch = time.mktime(prevTime.timetuple())+(prevTime.microsecond/1000000.)

    #Calculate the epoch of the current tick 
    #File last value is millisconds so convert to microseconds in datetime constructor
    c = re.search(r'.+center_(\d+)_(\d+)_(\d+)_(\d+)_(\d+)_(\d+)_(\d+).jpg', current)
    currTime = datetime.datetime(int(c.groups(1)[0]), int(c.groups(1)[1]), int(c.groups(1)[2]),
            int(c.groups(1)[3]), int(c.groups(1)[4]), int(c.groups(1)[5]), (int(c.groups(1)[6]) * 1000))
    currEpoch = time.mktime(currTime.timetuple())+(currTime.microsecond/1000000.)

    dt = (currEpoch - prevEpoch)

    if dt > 1:
        print("Warning : dt over 1, so setting to 1, from pictures:")
        print(prev)
        print(current)
        dt = 1

    return dt

#Fan cannot be set to any speed, it must be ramped up and down
#Simulate this by linear equations that ramp up in 2 seconds
#And ramp down in two seconds
def changeCoolingThrottle(coolingThrottle, setThrottle, dt):
    #Make sure the throttle being set to is between 0 and 1
    setThrottle = 1 if (setThrottle > 1) else setThrottle
    setThrottle = 0 if (setThrottle < 0) else setThrottle

    if setThrottle == coolingThrottle:
        #Dont need to calculate anything
        return setThrottle
    elif setThrottle > coolingThrottle:
        #Need to calculate an increase
        #Increase is not able to be more than 10% per 0.2 seconds
        #Caulculate the maximum increase for the dt
        #Get the current x value (time)
        t = coolingThrottle * 2.0
        #Get the highest speed possible with the dt
        x = t + dt
        maxThrottle = x / 2.0
        #If the attempted fan speed to set is more than that maximum allowable for the dt
        #Just set it to the maximum allowable
        newThrottle = maxThrottle if (maxThrottle < setThrottle) else setThrottle
    else:
        #Need to calculate a decrease
        #Not able to decrease more than 10% every 1/3 seconds
        t = coolingThrottle * 2.0
        x = t - dt
        minThrottle = x / 2.0
        newThrottle = minThrottle if (minThrottle > setThrottle) else setThrottle

    #Make sure everything is still in bounds, as the log functions dont fit exactly
    newThrottle = 1 if (newThrottle > 1) else newThrottle
    newThrottle = 0 if (newThrottle < 0) else newThrottle
    #Save the new cooling throttle
    return newThrottle

#Calculate the acceleration which is the change in speed since the last dt
#Take in the current speed in m/s, but the previous line that we will work with
def calculateAcceleration(speedms, prevLine, dt):
    #Get the previous acceleration
    prevVelocity = float(prevLine.split(',')[6]) * mphTomps
    acceleration = (speedms - prevVelocity) / dt

    print("Acceleration : " + str(acceleration) + "m/s2")

    return acceleration

# Calcualte the drain on the batteriries
#TODO: Maybe, work out the battery drain from how fast the car is driving
# Drain from running the fan
# Drain is very large approximation with a linear drain on the batteries!!
def calculateBatteryDrain(thisBattCapacity, coolingThrottle, drivingPower, dt):
    #Use the fan throttle to scale the instanteous current draw of the fans
    cellCurrentDraw = fanCurrent * coolingThrottle
    #Current is the flow per second, so also need to scale by dt
    cellCurrentDraw *= dt
    # Add the current that is drawn by the motor, by dividing the driving power by the nominal battery voltage
    # This power is already instantaneous in dt
    cellCurrentDraw += drivingPower / battVoltageNom

    #print(drivingPower)
    print("Instantaneous current " + str(cellCurrentDraw) + "A")
    print("dt : " + str(dt) + "s")

    #No power is consumed if the cellCurrentDraw is 0
    if cellCurrentDraw == 0:
        return thisBattCapacity

    #Remove this consumed power from the battery capacity
    #Work out how many seconds are left when this draw happens
    timeLeftHours = thisBattCapacity / cellCurrentDraw
    timeLeftSeconds = timeLeftHours * 3600.0
    #We are working in time units of dt, we are drawing for dt seconds
    timeLeftSeconds -= dt
    #Work in reverse to get the capacity after drawing the power
    timeLeftHours = timeLeftSeconds / 3600.0
    thisBattCapacity = timeLeftHours * cellCurrentDraw


    return thisBattCapacity

#Process the input file to work out the power at each point
#Print it to a file
def processFile(filePath):
    #open this new file and get all the lines
    with open(filePath) as f:
        processLine = f.readlines()
        # you may also want to remove whitespace characters like `\n` at the end of each line
        processLine = [x.strip() for x in processLine] 

    #Open this output file for writing (the same filename as the read file, but in the same 
    #location as the python testbench script)
    fileName = filePath.split('/')[-1] 
    if verbOutput:
        fileName = "traindata_" + fileName

    writeFile = open(fileName, "w")

    headerLine = "leftpic, middlepic, rightpic, steering angle, break, throttle, speedmph, battery temp, battery %"
    if verbOutput:
        headerLine += ",acceleration, speedMS, coolingPower, generatedHeat, instantaneousPower"

    headerLine += "\n"
    writeFile.write(headerLine)

    #Define variables for each file (race)
    prevLine = processLine[0]
    dt = 0
    temp = Tamb
    # Cooling throttle
    coolingThrottle = 0.0
    setCool = 1.0
    # Reset the battery capacity
    thisBattCapacity = battCapacity

    #Go through all these lines, each tick of the race
    #Each tick of the race is an varaible amount of time, dt
    #It is important it is calculated at the start of each tick, and then all units in time
    #Are scaled by dt
    for line in processLine[1:]:
        print('--------------')
        #.csv delimiter is ,
        lineData = line.split(',')

        #The pictures in the first column have the timestamp, used to calculate dt
        currentPic = lineData[0]
        prevPic = prevLine.split(',')[0]

        #calculate the new dt 
        dt = calculateDt(prevPic, currentPic)

        if coolingThrottle == 1:
            setCool = 0

        coolingThrottle = changeCoolingThrottle(coolingThrottle , 1, dt)

        #The power is calculated by working out the cooling in watts per dt of the battery
        #And then the power generated by the heat of driving is calculated

        #This is the number of watts of heat taken away per dt from the airflow
        coolingPower = calculateCooling(coolingThrottle, dt)

        #Get the speed in km (given in miles from the simulator)
        speedMS = float(lineData[6]) * float(mphTomps)
        #Some of the very low speeds from the sumulation come out as 1E-6 which creates spikes
        #So remove these
        speedMS = 0 if speedMS < 0.5 else speedMS

        print("Speed " + str(speedMS) + "m/s")

        acceleration = calculateAcceleration(speedMS, prevLine, dt)

        #Calculate the power which depends on acceleration and decelleration
        if (acceleration > 0):
            #Accelerating
            drivingPower = instantaneousPowerDrive(acceleration, speedMS, dt)
        elif (acceleration < 0):
            #Breaking, 60% efficiency with regen breaking
            #It's a negative because its energy back to the battery
            acceleration = acceleration * -1 * regenEfficiency
            drivingPower = -1.0 * instantaneousPowerBreak(acceleration, speedMS, dt)

        #print("Drive power " + str(abs(drivingPower)) + "W")
        print("Cooling power " + str(coolingPower) + "W")

        #Not all the driving power is turned into heat, just the i2r losses
        #We take the power for the heat to always be positive, as we are generating heat even with
        #generation we take the absolute value of the driving power
        #V=IR, P=I2R
        driveCurrent = abs(drivingPower) / battVoltageNom
        generatedHeat = driveCurrent ** 2 * battResistance

        print("Generated heat " + str(generatedHeat) + "W")

        #The instantaneous power generated in the cells is the driving power minues the cooling power
        instantaneousPower = abs(generatedHeat) - coolingPower
        print("Instantenous power " + str(instantaneousPower) + "W")
        #Temperature cannot go lower than coolingFloor
        instantaneousPower = 0 if (temp < coolingFloor and instantaneousPower < 0) else instantaneousPower

        #Using q=m*c*Delta 
        dTemp = float(instantaneousPower) / (float(battMass) * float(specHeatCap) * dt)

        # Change the current temperature by the temperature change calculated
        temp = temp + dTemp

        print ("Temperature : " + str(temp - 273))

        # Finally, work out the battery usage. Drive power is 55% efficiency as an estimation with the
        # Regen braking to the battery
        drivingPower = (drivingPower * regenEfficiency) if drivingPower < 0 else drivingPower
        thisBattCapacity = calculateBatteryDrain(thisBattCapacity, coolingThrottle, drivingPower, dt)

        #--------------- Write the output line -------------------#
        # Write the current data to the processed CSV file, it is the same data, but with the temperature and 
        # battery life appended onto the end
        #Work out the percentage decrease
        batteryPercentage = (thisBattCapacity / battCapacity) * 100.0
        #Get this as a string with two decimal places (cut, not rounded)
        wholePercentage = str(batteryPercentage).split('.')[0]
        decimPercentage = str(batteryPercentage).split('.')[1]
        batteryRemaining = str(wholePercentage + "." + decimPercentage[0:2])
        print("Battery remaining : " + batteryRemaining + "%")
        # Create the line to write, and write it to the file
        writeLine = line + "," + str(temp - 273)[0:5] + "," + batteryRemaining

        if verbOutput:
            #Then add extra infomation to the line, 
            #such as acceleration, speedMS, coolingPower, generatedHeat, instantaneousPower
            writeLine += "," + str(acceleration) + "," + str(speedMS) + ","  + str(coolingPower) + "," + \
                    str(generatedHeat) + "," + str(instantaneousPower)
        
        writeLine += "\n"
        writeFile.write(writeLine)

        # Save this line as the previous 
        prevLine = line

    #Close the current filehandle for writing
    writeFile.close()

    return

########################Script body#############################

filePath = "/Users/Matt/google_drive/documents/uni/year_3/EE30147_40148_GDBP_MEng/individual/scripts/heatprofileFilesList";

# First argument may either by a python controller to control the fan temperature
# Or if a flag for -verb is set, print out extra data to use with the machine learning
if (len(sys.argv) > 1):
    if sys.argv[1] == "-verb":
        verbOutput = True
        print("Printing verbose amount of data used to train machine learning model")
    else:
        print("Testing a module to control the fan")

# If a filepath has been given in the command line, use that
# Else, use the default one
if (len(sys.argv) < 3):
    # Use the default filepath
    filePath = filePath
else:
    filePath = sys.argv[2]

#Open the list of files to go through, 
try:
    with open(filePath) as f:
        processFilePaths = f.readlines()
        # you may also want to remove whitespace characters like `\n` at the end of each line
        processFilePaths = [x.strip() for x in processFilePaths] 
except IOError:
    print("Error, unable to find list file : " + filePath)

#Remove first item from processFilePaths as this is just the file header
processFilePaths.pop(0)

#For every required file
for row in processFilePaths:
    #Try to process this file
    try:
        print("Processing file : " + row)
        processFile(row)
    except IOError:
        print("Error, unable to find list file : " + row)

